function main(){cancelAnimationFrame(animationFrameId),document.body.querySelectorAll("canvas").forEach((canvas=>canvas.remove()));var canvas=document.createElement("canvas"),content=document.getElementById("content");canvas.style.position="fixed",canvas.style.zIndex=-1,canvas.style.top=0,canvas.style.left=0,content.appendChild(canvas);var gl=canvas.getContext("webgl");if(gl){resizeCanvas(),ResizeManager.attach(resizeCanvas);var vertices=new Float32Array([-1,-1,1,-1,-1,1,1,1]),vertexShader=createShader(gl.VERTEX_SHADER,"\n            attribute vec2 position;\n            varying vec2 v_texCoord;\n            void main() {\n                v_texCoord = position * 0.5 + 0.5;\n                gl_Position = vec4(position, 0.0, 1.0);\n            }\n        "),fragmentShader=createShader(gl.FRAGMENT_SHADER,"\n            precision mediump float;\n            varying vec2 v_texCoord;\n            uniform float time;\n\n            void main() {\n                float contrast = 1.0; // 0.3;\n                \n                // Apply zoom-out effect\n                vec2 zoomUvR = v_texCoord * 8.0;\n                float wave = sin(zoomUvR.x) + sin(time * 1.17);\n                float offsetR = sin(zoomUvR.x + sin(time)) + sin(zoomUvR.y + wave) * (cos(wave + time));\n                float r = (sin((time + zoomUvR.y) * 0.5) * offsetR) + 0.5;\n                r *= contrast;\n\n                float time2 = time + 1.141;\n                vec2 zoomUvG = v_texCoord * 6.0;\n                wave = sin(zoomUvG.x) + sin(time2 * 0.49);\n                float offsetG = sin(zoomUvG.x + sin(time2)) + sin(zoomUvG.y + wave) * (cos(wave + time2));\n                float g = (sin((time2 + zoomUvG.y) * 0.5) * offsetG) + 0.5;\n                g *= contrast;\n\n                float time3 = time + 2.141;\n                vec2 zoomUvB = v_texCoord * 4.0;\n                wave = sin(zoomUvB.x) + sin(time3 * 0.78);\n                float offsetB = sin(zoomUvB.x + sin(time3)) + sin(zoomUvB.y + wave) * (cos(wave + time3));\n                float b = (sin((time3 + zoomUvB.y) * 0.5) * offsetB) + 0.5;\n                b *= contrast;\n\n                vec3 color = vec3(r, g, b);\n\n                // Round vignette\n                vec2 center = vec2(0.5);\n                float dist = distance(v_texCoord, center);\n                float radius = 0.35;     // circle radius before fade starts\n                float softness = 0.15;    // controls the fade gradient\n                float vignette = smoothstep(radius, radius + softness, dist);\n                color = mix(color, vec3(0.0), vignette);\n\n                // // Square vignette\n                // vec2 edgeFade = smoothstep(vec2(0.0), vec2(0.2), v_texCoord) * smoothstep(vec2(1.0), vec2(0.8), v_texCoord);\n                // float vignette = edgeFade.x * edgeFade.y;\n                // color = mix(vec3(0.0), color, vignette);\n\n                gl_FragColor = vec4(color, 1.0);\n            }\n        "),program=gl.createProgram();gl.attachShader(program,vertexShader),gl.attachShader(program,fragmentShader),gl.linkProgram(program),gl.useProgram(program);var timeLocation=gl.getUniformLocation(program,"time"),lastFrameTime=0,buffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);var positionLocation=gl.getAttribLocation(program,"position");gl.enableVertexAttribArray(positionLocation),gl.vertexAttribPointer(positionLocation,2,gl.FLOAT,!1,0,0),function animate(now){now-lastFrameTime>=16.666666666666668&&(lastFrameTime=now,gl.uniform1f(timeLocation,.001*now),gl.drawArrays(gl.TRIANGLE_STRIP,0,4)),animationFrameId=requestAnimationFrame(animate)}()}else console.log("WebGL not supported");function resizeCanvas(){canvas.width=window.innerWidth,canvas.height=window.innerHeight,gl.viewport(0,0,canvas.width,canvas.height)}function createShader(type,source){var shader=gl.createShader(type);return gl.shaderSource(shader,source),gl.compileShader(shader),gl.getShaderParameter(shader,gl.COMPILE_STATUS)?shader:(console.error("Shader compilation failed:",gl.getShaderInfoLog(shader)),gl.deleteShader(shader),null)}}main();