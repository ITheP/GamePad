function main(){cancelAnimationFrame(animationFrameId),document.body.querySelectorAll("canvas").forEach((canvas=>canvas.remove()));var canvas=document.createElement("canvas"),content=document.getElementById("content");canvas.style.position="fixed",canvas.style.zIndex=-1,canvas.style.top=0,canvas.style.left=0,content.appendChild(canvas);var gl=canvas.getContext("webgl");if(gl){resizeCanvas(),ResizeManager.attach(resizeCanvas);var vertices=new Float32Array([-1,-1,1,-1,-1,1,1,1]),vertexShader=createShader(gl.VERTEX_SHADER,"\n            attribute vec2 position;\n            varying vec2 v_texCoord;\n            void main() {\n                v_texCoord =  position * 0.5 + 0.5;\n                gl_Position = vec4(position, 0.0, 1.0);\n            }\n        "),fragmentShader=createShader(gl.FRAGMENT_SHADER,"\n            precision mediump float;\n            uniform sampler2D u_image;\n            uniform float time;\n            varying vec2 v_texCoord;\n\n            void main() {\n                // Create varying zoom based on position\n                float zoomFactor = (sin(time * 0.17) + 1.0) + sin(v_texCoord.x * 5.0 + v_texCoord.y * 5.0 + time) * 0.1;\n\n                // Adjust texture coordinates based on zoom level\n                vec2 zoomedCoord = (v_texCoord - 0.5) * zoomFactor + 0.5;\n\n                float angle = sin(time * 0.01) * 20.0; // Rotation speed\n                float cosA = cos(angle);\n                float sinA = sin(angle);\n                mat2 rotationMatrix = mat2(cosA, -sinA, sinA, cosA);\n\n                vec2 rotatedCoord = rotationMatrix * (zoomedCoord - 0.5) + 0.5;\n\n                // Apply distortion waves\n                float wave = sin(v_texCoord.y * 17.0 + time) * 0.02;\n                float wave2 = sin(v_texCoord.x * 21.17 + (time * 1.517)) * 0.02;\n                vec2 displacedCoord = rotatedCoord + vec2(wave, wave2);\n                displacedCoord.y = 1.0 - displacedCoord.y;\n\n                float offsetP = 0.3;\n                float offsetM = -0.3;\n                float offsetP2 = 0.6;\n                float offsetM2 = -0.6;\n\n                vec4 glowColor = vec4(0.0);\n                float period = sin(v_texCoord.x + time * 0.1) * 15.0 + sin(v_texCoord.y + time * 0.17) * 15.0;\n                float glowIntensity = ((sin(v_texCoord.x * period + v_texCoord.y * period + time) + 1.0) * 0.1) + 0.1;\n\n                glowColor += texture2D(u_image, displacedCoord + vec2( offsetP, offsetP)) * glowIntensity;\n                glowColor += texture2D(u_image, displacedCoord + vec2( offsetM, offsetP)) * glowIntensity;\n                glowColor += texture2D(u_image, displacedCoord + vec2( offsetP, offsetM)) * glowIntensity;\n                glowColor += texture2D(u_image, displacedCoord + vec2( offsetM, offsetM)) * glowIntensity;\n\n                glowColor += texture2D(u_image, displacedCoord + vec2( offsetP2, offsetP2)) * glowIntensity;\n                glowColor += texture2D(u_image, displacedCoord + vec2( offsetM2, offsetP2)) * glowIntensity;\n                glowColor += texture2D(u_image, displacedCoord + vec2( offsetP2, offsetM2)) * glowIntensity;\n                glowColor += texture2D(u_image, displacedCoord + vec2( offsetM2, offsetM2)) * glowIntensity;\n\n                vec4 texColor = texture2D(u_image, displacedCoord);\n\n                glowColor = max(texColor, glowColor);\n                glowColor = glowColor - texColor;\n\n                vec3 bgColor = vec3(0.0); // Black background\n                vec3 finalColor = mix(bgColor.rgb, glowColor.rgb, texColor.a);\n\n                // // Round vignette\n                // vec2 center = vec2(0.5);\n                // float dist = distance(v_texCoord, center);\n                // float radius = 0.35;     // circle radius before fade starts\n                // float softness = 0.15;    // controls the fade gradient\n                // float vignette = smoothstep(radius, radius + softness, dist);\n                // finalColor = mix(finalColor, vec3(0.0), vignette);\n\n                // // Square vignette\n                // vec2 edgeFade = smoothstep(vec2(0.0), vec2(0.2), v_texCoord) * smoothstep(vec2(1.0), vec2(0.8), v_texCoord);\n                // float vignette = edgeFade.x * edgeFade.y;\n                // finalColor = mix(vec3(0.0), finalColor, vignette);\n\n                //gl_FragColor = vec4(v_texCoord.x, v_texCoord.y, 1.0, 1.0);\n                gl_FragColor = vec4(finalColor, 1.0);\n            }\n        "),program=gl.createProgram();gl.attachShader(program,vertexShader),gl.attachShader(program,fragmentShader),gl.linkProgram(program),gl.useProgram(program);var timeLocation=gl.getUniformLocation(program,"time"),lastFrameTime=0,image=new Image;image.onload=()=>{var buffer=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,buffer),gl.bufferData(gl.ARRAY_BUFFER,vertices,gl.STATIC_DRAW);var positionLocation=gl.getAttribLocation(program,"position");gl.enableVertexAttribArray(positionLocation),gl.vertexAttribPointer(positionLocation,2,gl.FLOAT,!1,0,0),gl.activeTexture(gl.TEXTURE0);var texture=gl.createTexture();gl.bindTexture(gl.TEXTURE_2D,texture),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.REPEAT),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.REPEAT),gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR),gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);var textureLocation=gl.getUniformLocation(program,"u_image");gl.uniform1i(textureLocation,0),function animate(now){now-lastFrameTime>=16.666666666666668&&(lastFrameTime=now,gl.uniform1f(timeLocation,.001*now),gl.drawArrays(gl.TRIANGLE_STRIP,0,4)),animationFrameId=requestAnimationFrame(animate)}()},image.src="img/logo.2.png"}else console.log("WebGL not supported");function resizeCanvas(){canvas.width=window.innerWidth,canvas.height=window.innerHeight,gl.viewport(0,0,canvas.width,canvas.height)}function createShader(type,source){var shader=gl.createShader(type);return gl.shaderSource(shader,source),gl.compileShader(shader),gl.getShaderParameter(shader,gl.COMPILE_STATUS)?shader:(console.error("Shader compilation failed:",gl.getShaderInfoLog(shader)),gl.deleteShader(shader),null)}}main();